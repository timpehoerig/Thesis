In the following sections all auxiliary functions that are used in the typeinference algorithm are specified.

\subsection{Substitution}

\begin{align*}
1&: \txn{T}{X}{N}
\\
\\
2&: \tsxsn{T}{X}{N}
\\
\\
3&: \tsxsns{T}{X}{N}
\end{align*}

The first rule (1) shows the standart substitution rule. In a non variable type N every variable type X is replaced by the given type T.
\\
The second rule (2) is short for \inl{[T_1/X_1, ... , T_n/X_n]N}.
\\
The third rule (3) is short for \inl{[T_1/X_1, ... , T_n/X_n]N_1, ... , [T_1/X_1, ... , T_n/X_n]N_n}.
\\
These rules are implemented in different functions using pattern matching on the different type types.

\subsection{Substitution on constraints}

\begin{align*}
    1:& \quad \txn{T}{a}{C}\\
    \\
    2:& \quad \txn{a}{b}{C}
\end{align*}

Substitution is also possible on constraint sets. Type variables can be replaced by types (1) or by other type variables (2).

\subsection{Subtyping}

\begin{figure}[H]
    \begin{align*}
1&: \ \Delta \vdash \text{T} <: \text{T}
\\
\\
2&: \ \frac{\Delta \vdash \text{S} <: \text{T} \quad \Delta \vdash \text{T} <: \text{U}}{\Delta \vdash \text{S} <: \text{U}}
\\
\\
3&: \ \Delta \vdash \text{X} <: \Delta(\text{X})
\\
\\
4&: \ \frac{
    \begin{matrix}
        \classheader \ \{...\} \\
        \Delta \vdash \ot{T} ok \quad \Delta \vdash \ot{T} <: \tsxsns{T}{X}{N}
    \end{matrix}}
    {\Delta C<\ot{T}> \ ok}
    \end{align*}
    \caption{Subtyping}
    \label{subtyping}
\end{figure}

By definition a type is always a subtype of itself. Subtyping is also transitive and the environment delta $\Delta$ maps every type variable to its upper bound.

\subsection{Field Lookup}

\begin{align*}
    \text{fields}(\text{Object}) = \{\}\\
    \\
    \frac{\class{S}{f} \quad \text{fields}(\tsxsn{T}{X}{N}) = \ot{U} \ \ot{g} }{\text{fields}(\nvt{C}{T}) = \ot{U} \ \ot{g}, \ \tsxsns{T}{X}{S} \ \ot{f}}\\
\end{align*}

A field lookup on a class \inl{C} returns every field of \inl{C} with its type and also every field with its type for all superclasses of \inl{C}. \inl{Object} itself has no fields thus \inl{fields(Object)} returns the empty dictionary.
The type variables need a special treatment here. The field types of a class \inl{C} may include type variables, these must be substituted with the types the class is instantiated with. This also needs to be done for the superclass of \inl{C}.

\subsection{Method Type Lookup}

In Featherweight Generic Java methods of superclasses are inherited. Hence method type lookups on classes with or without the method defined can be possible. If the method is defined in the class, the method type signature can be read of the method type environment. Once again generic type variables may occur in that type signature and must be substituted.
If the method is not defined in the class \inl{C}, then \inl{mtype} is called on the superclass of \inl{C} where generic type variables are substituted by the types the class \inl{C} is instantiated with.

\subsection{Generic Supertype}

\begin{align*}
    \text{genericSupertype} (\text(C), \ot{T}, \text{C} ) = \ot{T}\\
    \\
    \frac{ \text{class} \ \text{C} \yp \vartriangleleft \nvt{C'}{M} \ \{ ... \} }{ \text{genericSupertype} ( \text{C}, \ot{T}, \text{D} ) = \text{genericSupertype} ( \text{C'}, \tsxsns{T}{Y}{M}, \text{D} ) }\\
\end{align*}

GenericSupertype takes two subtype related classes C and D and a list of types $\ot{T}$ as arguments. If the two classes are the same, then the list of types $\ot{T}$ is returned. Otherwise the function is recursively called with the superclass C' of C.
However, the superclass C' may have different generic type variables than C. That is why $\ot{T}$ is replaced by $\ot{M}$ where $\ot{M}$ are the generic type variables of C', but the generic type variables $\ot{Y}$ may occur in $\ot{M}$, thus $\ot{T}$ is substituted for $\ot{Y}$ in $\ot{M}$.
