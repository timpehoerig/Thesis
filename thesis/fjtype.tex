\inl{FJType} is the function that generates constraints for a class. It takes the definition of that class and the method type environment, where all the method signatures that have already been inferred from earlier classes are in.
It returns a tuple consisting of a set of method signatures $\lambda$ with new type variables and a constraint set C which constraints those type variables.

In Featherweight Generic Java methods can be overridden with covariant types. If a method is overridden or not can be checked by calling \inl{mtype} on the superclass.
If no method signature is found a new method signature for that method can be initialized with some new type variables which have only the constraint to be subtypes of \inl{Object}.
However, if the \inl{mtype} lookup is successful the constraints look different. The return type of the current method needs to be a subtype of the return type of the overridden method.
Whereas the types of the arguments stay the same. Then, the method signature is added to the global method type environment.
This is done for every method definition of the class. Next, the \inl{MethodType} function is called on every method defined in the class. Hence, every method has access to the full method type environment.
The method type environment and the generated constraints together with the constraints generated by \inl{MethodType} are returned.

\begin{align*}
    \text{FJType}(\sprod{0.7}, & \ \classheader \{ \ot{T} \ \ot{f}; \ \ot{M} \}) = \\
    \text{let} \ & \overline{a}_m \ \text{be fresh type variables for each m} \in \ot{M} \\
    & \overline{\lambda}_0 = \{\cm : \ \yp \ot{T} \to a_m \\
    & \quad \quad \quad \quad \quad \quad | \ \text{m} \in \ot{M}, \ \mtype = \yp \ot{T} \to \text{T} \}\\
    & C_0 = \{ a_m < \text{T} \ | \ \text{m} \in \ot{M}, \ \mtype = \yp \oto{T} \}\\
    & \overline{\lambda}' = \{ ( \cm : \ \overline{a} \to a_m ) \\
    & \quad \quad \quad \quad \quad \quad | \ \text{m} \in \ot{M}, \ \mtype \ \text{not defined}, \ \fresh{\overline{a}} \}\\
    & C_m = \{\{ a_m < \text{Object}, \overline{a} < \ot{Object} \} \ | \ ( \cm : \ \overline{a} \ \to a_m) \in \overline{\lambda}' \} \\
    & \sprod{0.7} = \sprod{0.7} \cup \overline{\lambda}' \cup \overline{\lambda}_0\\
\text{in} \ &(\sprod{0.7}, C_0 \cup C_m \cup \bigcup_{ \text{m} \in \ot{m} } \text{TYPEMethod}(\sprod{0.7}, C \vv{\ot{X}}, \text{m}))\\
\end{align*}

\subsection{Method Type}

\begin{align*}
    \text{TYPEMethod}&(\sprod{0.7}, \ \text{C<} \ot{X} \text{>}, \ \text{m} ( \ot{x} ) \{ \ \text{return e}; \} ) = \\
    \text{let} \ &\yp \oto{\text{T}} = \sprod{0.7} ( \cm ) \\
    & ( \text{R}, \text{C} ) = \text{TYPEExpr} (( \sprod{0.7}; \{ \text{this} : \text{C<} \ot{X} \text{>} \} \cup \{ \ot{x} : \ot{T} \} ) , \text{e} ) \\
    \text{in} \ \  & \text{C} \cup \{ \text{R} < \text{T} \}\\
\end{align*}

\inl{TYPEMethod} takes the method type environment, the class header $\nvt{C}{X}$ of the class that is currently checked and the method definitions as arguments.
It first brings the type signature of the current method in scope and then calls \inl{TYPEExpr} on the expression \inl{e} inside the method's body. In this call a type environment for variables is created. Where \inl{this} has the type $\nvt{C}{T}$ and the types of the method's arguments are read off the type signature which was brought into the scope earlier.
\inl{TYPEExpr} returns a tuple of the type \inl{R} of \inl{e} and the generated constraints. The generated constraints together with the constraint, that \inl{R} must be a subtype of the return type of the method signature is returned.

\subsection{Expression Type}
The last function for generating constraints is \inl{TYPEExpr}. It takes the method type environment, the variable type environment created by \inl{TYPEMethod} and an expression \inl{e} as arguments.
The expression \inl{e} is matched against the five possible forms for an expression and is handled differently for each.

\subsection{Variable}

\begin{align*}
    \texpr{\text{x}} = (\overline{\eta} (\text{x}), \emptyset)\\
\end{align*}

If the expression is a simple variable its type is looked up in the variable type environment. Its type together with an empty set is returned. The empty set is returned because a simple variable does not generate any constraints.

\subsection{Field Lookup}

\begin{align*}
    \texpr{e.f} &= \\
    \text{let} \ &( \text{R}, C_R ) = \texpr{e} \\
    &\fresh{a} \\
    &\text{c} = \text{oc} \{ \{ \text{R} < \text{C<} \ot{a} \text{>}, \text{a} = \tsxsn{a}{X}{T}, \ot{a} < \tsxsns{a}{X}{N} \ | \ \fresh{\ot{a}} \} \\
    & \quad \quad \quad \quad | \ \text{T f} \in \class{X}{N} \}\\
    \text{in} \ \ & (\text{a}, (\text{C}_R \cup \{ \text{c} \} ))
\end{align*}

In case of a field lookup \inl{e.f} first the \inl{TYPEExpr} function is called recursively on the expression \inl{e}, returning a
type R and a constraint set $C_R$. Now, the difficult part is to find out which class the field \inl{f} belongs to. The solution is simple:
Just generate a constraint set for every class \inl{C} that has the field \inl{f} defined and put them together in one big or-constraint.
The constraint set for one class consists of three kinds of constraints: One that constraints the returned type R to be a subtype
of the class \inl{C} where the type parameters of \inl{C} are replaced by some fresh type variables $\ot{a}$. Another one that constraints the resulting type of the field lookup
to be equal to the type of the corresponding field in \inl{C}. And finally, one that constraints every $a_i$ of $\ot{a}$ to be a subtype of the bounding type of the corresponding type parameter it replaces.

\subsection{Method Invocation}

\begin{align*}
    \texpr{\text{e.m}( \ot{e} )} &= \\
    \text{let} \ &( \text{R}, C_R ) = \texpr{\text{e}} \\
    &\forall{e_i} \in \ot{e} : ( R_i, C_i ) = \texpr{e_i} \\
    &\fresh{a} \\
    &\text{c} = \text{oc} \{ \{ \text{R} < \text{C<} \ot{a} \text{>}, \text{a} = \tsxsnd{b}{Y}{a}{X}{T}, \ot{R} < \tsxsnsd{b}{Y}{a}{X}{T}, \\
    & \quad \quad \quad \quad \ot{b} < \tsxsnsd{b}{Y}{a}{X}{P}, \ot{a} < \tsxsns{a}{X}{N} \ | \ \ot{a}, \fresh{b} \} \\
    & \quad \quad \quad \quad | \ ( \cm : \yp \oto{T} ) \in \sprod{0.7} \}\\
    \text{in} \ \ & (\text{a}, (\text{C}_R \cup \bigcup_{i} \text{C}_i \cup \{ \text{c} \} ))
\end{align*}

A method invocation imposes the same problem that a field lookup did and thus is solved in a similar way. But first, for the
expression that the method \inl{m} is invoked on and every expression that is passed as an argument to \inl{m}, \inl{TYPEExpr}
is called recursively on. Then, for every method signature of a method named \inl{m} in the method type environment a constraint
set is generated. This set of constraints contains five kinds of constraint: Three of them are very similar to the ones generated for a
field lookup except that two different kinds of fresh type variables are created. One for every generic type parameter the class has and
one for every generic type parameter the method signature has. The other two constraints are new. The first constraint constraints the type of the arguments for \inl{m} to be subtypes of the
argument types imposed by the method signature. The second constraint constraints all fresh type variables generated for the type parameters
of the method signature to be a subtype of the corresponding bounding types. All those constraint sets are put together to one big or-constraint which then is returned.

\subsection{Object Creation}

\begin{align*}
    \texpr{\text{new} \ \text{C}(\ot{e})} &=\\
    \text{let} \ & \forall{e_i} \in \ot{e} : (\text{R}_i, \text{C}_i) = \texpr{\text{e}_i}\\
    & \fresh{\ot{a}}\\
    & \text{fields}(\nvt{C}{a}) = \ot{T} \ \ot{f}\\
    & \text{C} = \{ \ot{R} < \ot{T} \cup \{ \ot{a} < \tsxsns{a}{C}{N} \} \quad \text{where} \\
    & \quad \quad \quad \classheader \{ ... \} \}\\
    \text{in} \ \ & ( \nvt{C}{a}, \text{C} \cup \bigcup_{i} \text{C}_i )
\end{align*}

The constraints generated for an object creation are rather simple. \inl{TYPEExpr} is called recursively for every argument. Then, the types of all
fields of the class that the new object is an instance of are brought in scope via the \inl{fields} function. Thus, for every field a fresh type variable is introduced.
Those fresh type variables must be subtypes of their corresponding upper bound and all returned types of the recursive calls have to be subtypes of the field they are bound to.

\subsection{Cast}

\begin{align*}
    \texpr{(\text{N})\text{e}} &=\\
    \text{let} \ &= (\text{R}, \text{C}) = \texpr{\text{e}}\\
    \text{in} \ \ &(\text{N}, \text{C})
\end{align*}

For a cast the \inl{TypeExpr} is called recursively on the expression that is casted. This recursive call returns a type and a constraint set. However, instead of returning that type, the type the expression is casted to and the constraint set are returned.
