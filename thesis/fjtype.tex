\inl{FJType} is the function that generates constraints for a class. It takes the definition of that class and the method type environment where all the method signatures that have already been inferred from earlier classes are in.
It returns a tuple consisting of a set of method signatures 'lambda' with new type variables and a constraint set C which constraints those type variables.

In Featherweight Generic Java methods can be overridden with covariant types. If a method is overridden or not can be checked by calling \inl{mtype} on the class's supertype.
If it does not find a method signature the type signature can be initialized with some new type variables which have only the constraint to be subtypes of \inl{Object}.
However, if the \inl{mtype} lookup is successful the constraints look different. The return type of the current method needs to be a subtype of the return type of the overridden method.
Whereas the types of the arguments stay the same. Then the method signature is added to the global method type environment.
This is done for every method definition of the class. Then the \inl{MethodType} function is called on every method defined in the class. Therefore, every method has access to the full method type environment.
The method type environment and the generated constraints together with the constraints generated by \inl{MethodType} are returned.

\begin{figure}[H]
    \begin{align*}
        \text{FJType}(\prod, \classheader \{ \ot{T} \ \ot{f}; \ \ot{M} \}) = \\
        \text{let} \ \overline{a}_m \ \text{be fresh type variables for each m} \in \ot{M} \\
        \overline{\lambda}_0 = \{\cm : \ \yp \ot{T} \to a_m \ | \ \text{m} \in \ot{M}, \ \mtype = \yp \ot{T} \to \text{T} \}\\
        C_0 = \{ a_m < \text{T} \ | \ \text{m} \in \ot{M}, \ \mtype = \yp \oto{T} \}\\
        \overline{\lambda}' = \{ ( \cm : \ \overline{a} \to a_m ) \ | \ \text{m} \in \ot{M}, \ \mtype \ \text{not \ defined}, \fresh{\overline{a}} \}\\
        C_m = \{\{ a_m < \text{Object}, \overline{a} < \ot{Object} \} \ | \ ( \cm : \ \overline{a} \ to a_m) \in \overline{\lambda}' \} \\
        \prod = \prod \cup \overline{\lambda}' \cup \overline{\lambda}_0\\
        \text{in} \ (\prod, C_0 \cup C_m \cup \cup{text{m} \in \ot{m}} \text{TYPEMethod}(\prod, C \vv{\ot{X}}, \text{m}))
    \end{align*}
    \caption{FJType}
    \label{fjtype}
\end{figure}

\subsection{Method Type}

\inl{MethodType} takes the method type environment, the class header \inl{C<\overline{X}>} of the class that is currently checked and the method definitions as arguments.
It first brings the type signature of the current method in scope and then calls \inl{TypeExpression} on the expression \inl{e} inside the body of the method. In this call also a type environment for variables is created, where \inl{this} has the type C<X'> and the arguments of the method are read from the type signature brought into the scope earlier.
\inl{TypeExpression} returns a tuple of the type \inl{R} of \inl{e} and the generated constraints. The generated constraints together with the constraint that \inl{R} must be a subtype of the return type of the method signature is returned.

\subsection{Type Expressions}
The last function for generating constraints is \inl{Type Expression}. It takes the method type environment, the variable type environment created by \inl{Type Method} and an expression \inl{e} as arguments.
The expression \inl{e} is matched against the five possible forms for an expression and is handled differently for each.

\subsection{Variable}
If the expression is a simple variable it's type is looked up in the variable type environment and together with an empty set is returned. The empty set is returned because a simple variable does not generate any constraints.

\subsection{Field Lookup}
In case of a field lookup \inl{e.f} first the \inl{Type Expression} function recursively is called on the expression \inl{e}, returning a
type R and a constraint set $C_R$. Now the difficult part is to find out which class the field \inl{f} belongs to. The solution is simple,
just generate a constraint set for every class \inl{C} that has the field \inl{f} and put them together in one big or-constraint.
The constraint set for one class consists of three constraints. One that constraints the returned type R to be a subtype
of the class \inl{C} where the type variables of \inl{C} are replaced by some fresh type variables \inl{\overline{a}}. One that constraints the resulting type of the field lookup
to be equal to the type of the corresponding field in \inl{C}. And another one that constraints every $a_i$ of \inl{\overline{a}} to be a subtype of the bounding type of the corresponding type variable it replaces.

\subsection{Method Invocation}
A method invocation imposes the same problem that a field lookup did and therefore is solved in a similar way. But first for the
expression the method \inl{m} is invoked on and every expression that is passed as an argument to \inl{m} \inl{Type Expression}
recursively is called on. Then for every method signature of a method with name \inl{m} in the method type environment an constraint set is generated.
