\begin{figure}[tp]
    \begin{align*}
        \text{T} &:= \text{X} \ | \ \text{N}\\
        \\
        \text{N} &:= \text{C} \vv{\ot{T}}\\
        \\
        \text{L} &:= \text{class} \ \text{C} \xn \ \vartriangleleft \ \text{D} \{ \ \ot{T} \ \ot{f} \ [\text{K}] \ \ot{M} \ \}\\
        \\
        \text{M} &:= \text{m}(\ot{x}) \ \{\text{return e}\}\\
        \\
        \text{e} &:= \text{x} \ | \ \text{e.f} \ | \ \text{e.m(}\ot{e}\text{)} \ | \ \text{new C(}\ot{e}\text{)} \ | \ \text{(C)e}
    \end{align*}
    \caption{Syntax}
    \label{syntax}
\end{figure}

Figure \ref{syntax} defines the syntax of Featherweight Generic Java: types (\inl{T} and \inl{N}), class definitions (\inl{L}), method definitions (\inl{M}) and expressions (\inl{e}).

\subsection{Types}

There are two different kinds of types (\inl{T}, \inl{U}, \inl{V}) in Featherweight Generic Java:
type parameters (\inl{X}, \inl{Y}, \inl{Z}) and types other than type parameters (\inl{N}, \inl{P}, \inl{Q}).
In the following $\ot{T}$ is written short for $\text{T}_1, \text{T}_2, ... \text{T}_n$.

\subsection{Class Definitions}

A class definition \inl{L} always begins with the keyword \inl{class} followed by its name. Then, every type parameter and its upper bound, that are used as a field type in the class definition, are declared within \inl{<>} writing $\vartriangleleft$ as shortcut for the keyword \inl{extends}.
This is followed by the name of the superclass indicated by another \inl{extends} in front of it. In the body of a class definition the fields (\inl{f}, \inl{g}) of the class are defined, writing their types in front of them. Followed by the optional constructor \inl{K} and all method definitions $\ot{M}$.

\subsection{Method Definition}

As this is a type inference algorithm, every type annotations of methods can be dropped. Leading a method definition only to consist of its name \inl{m}, its arguments $\ot{x}$ and a single expression \inl{e} which is returned.

\subsection{Expressions}

There are five different forms of an expression \inl{e}: a simple variable \inl{x}, a field lookup written \inl{e.f}, a method invocation that takes one expression for each argument, an object creation indicated by the keyword \inl{new} followed by the name of the new Object and its arguments, a cast.
A cast binds less than any other expression. Method calls and object creation do not need any instantiation of their generic type annotations.

\subsection{Type Annotation}

Every type annotation except for field types and their upper bounds in class definitions can be dropped.

\subsection{Constructor}

\begin{align*}
    \text{K} &:= \text{C}(\ot{f}, \ \ot{g}) \ \{ \text{super}(\ot{g}); \ \text{this}.\ot{f}=\ot{f}; \}
\end{align*}

In Featherweight Java as well as in Featherweight Generic Java a constructor is always required. The constructor has always the same form.
The name of the constructor is always the name of the class itself. For every field of the class the constructor takes exactly one argument which must have the same name as the field it belongs to.
The body of the constructor always consists of two parts. First, there is a call to super, which calls the constructor of the superclass. Here, all arguments for fields that are not defined in the current class are passed on to.
Second, every other argument is initialized in the form \inl{this.f=f}.

As a constructor does not contain any information that cannot be found somewhere else in the class definition, writing the constructor for every class definition is redundant and can be dropped in this implementation.
