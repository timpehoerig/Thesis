\subsection{Syntax}

\subsection{Types}

\begin{figure}
    \begin{align*}
        \text{T} &:= \text{X} \ | \ \text{N}
        \\
        \text{N} &:= \text{C} \vv{\ot{T}}
    \end{align*}
    \caption{Types}
    \label{types}
\end{figure}

There are two different kinds of types (\inl{T}, \inl{U}, \inl{V}) in Featherweight Generic Java.
Type variables (\inl{X}, \inl{Y}, \inl{Z}) and types other than type variables (\inl{N}, \inl{P}, \inl{Q}).
Writing \inl{\overline{T}} short for \inl{T_1, T_2, ... T_n}.

\subsection{Class Definitions}

\begin{figure}
    \begin{align*}
        \text{L} &:= \text{class} \ \text{C} \xn \ \vartriangleleft \ \text{D} \{ \ \ot{T} \ \ot{f} \ [\text{K}] \ \ot{M} \ \}
    \end{align*}
    \caption{Class Definitions}
    \label{classd_efinitions}
\end{figure}

A class definition \inl{L} always begins with the keyword \inl{class} followed by it's name. Then every type variable and it's upper bound that are used as a field type in the class definition are declared within \inl{<>} writing \inl{\vartriangleleft} as shortcut for the keyword \inl{extends}.
Followed by the name of the superclass. In the body of a classdefinition the fields (\inl{f}, \inl{g}) of the class are defined, writing their types infront of them. Followed by the optional constructor \inl{K} and all methoddefinitions \inl{\overline{M}}.

\subsection{Methoddefinition}

\begin{figure}
    \begin{align*}
        \text{M} &:= \text{m}(\ot{x}) \ \{\text{return e}\}
    \end{align*}
    \caption{Method Definitions}
    \label{method_definitions}
\end{figure}

As this is a type inference algorithm every type annotations of methods can be dropped. Leading a method definition only to consist of it's name \inl{m}, it's arguments \inl{\overline{x}} and a single expression \inl{e} wich is returned.

\subsection{Expressions}

\begin{figure}
    \begin{align*}
        \text{e} &:= \text{x} \ | \ \text{e.f} \ | \ \text{e.m(}\ot{e}\text{)} \ | \ \text{new C(}\ot{e}\text{)} \ | \ \text{(C)e}
    \end{align*}
    \caption{Expressions}
    \label{expressions}
\end{figure}

An expression \inl{e} can be in five different forms. First, a simple variable \inl{x}. Second, a field lookup written \inl{e.f}. Third, a method invocation that takes one expression for each argument. Fourth, an object creation indicated by the keyword \inl{new} followed by the name of the new Object and it's arguments. Fifth, a cast.
A cast binds less than any other expression. Notice how methodcalls and object creation do not need any instanciation of their generic type annotations.

\subsection{Typeannotation}

Every typeannotation except for field types and their upper bounds in classdefinitions can be dropped.

\subsection{Constructor}

\begin{figure}
    \begin{align*}
        \text{K} &:= \text{C}(\ot{f}, \ \ot{g}) \ \{ \text{super}(\ot{g}); \ \text{this}.\ot{f}=\ot{f}; \}
    \end{align*}
    \caption{Constructor}
    \label{constructor}
\end{figure}

In Featherweight Java as well as in Featherweight Generic Java a constructor is always required. The constructor has always the same form.
The name of the constructor is always the name of the class itself. For every field it takes excatly one argument wich must have the same name as the field it belongs to.
The body of the constructor always consists of two parts. First, a call to super, in wich all arguments with fieldnames defined in superclasses are passed on.
Second, every other argument is initialised in the form \inl{this.f=f}.

As a constructor does not contain any information that cannot be found somewhere else in the class definition, writing the constructor for every class definition is redundant and can be dropped in this implementation.
